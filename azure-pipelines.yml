# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:


trigger:
- main

pool:
  name: Default

#container: docker.io/node:latest

stages:
- stage: build
  jobs:
  - job: node
    container: docker.io/node:latest
    steps:
    - script: |
        git clone https://gitlab.com/Fx62/pokemones.git app
      displayName: 'Clone Repo'
    - script: |
        cd app
        npm install
        npm run build
      displayName: 'Build App'
    - publish: $(System.DefaultWorkingDirectory)/app/dist
      artifact: dist
- stage: deploy
  jobs:
  - job: openshift
    steps: 
    - download: current
      artifact: dist
    - script: |
        NAMESPACE=test-app-jandrade2
        APPNAME=app
        VERSION=v5
        oc login ${OS_URL} -u ${USERNAME} -p ${PASSWORD} --insecure-skip-tls-verify=true
        oc new-project ${NAMESPACE} || oc project ${NAMESPACE}
        oc get is ${APPNAME} && oc new-build --name ${APPNAME} --image-stream=openshift/nginx:1.20-ubi9 --binary --to=${APPNAME}:${VERSION} -o yaml |oc replace -f - || oc new-build --name ${APPNAME} --image-stream=openshift/nginx:1.20-ubi9 --binary --to=${APPNAME}:${VERSION} -o yaml |oc apply -f - 
        oc start-build ${APPNAME}  --from-dir $(Pipeline.Workspace)/dist --follow
        oc create deployment ${APPNAME} --image=image-registry.svc:5000/${NAMESPACE}/${APPNAME}:${VERSION} --port 8080 -o yaml --dry-run=client|oc apply -f - 
        oc expose deployment ${APPNAME} -o yaml --dry-run=client |oc apply -f -
        oc expose service ${APPNAME} -o yaml --dry-run=client |oc apply -f -
        oc get route ${APPNAME} -o jsonpath="{.spec.host}" 
      displayName: 'Publish APP'